{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":5007657540716867810,"abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":232,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"public"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"nonce","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18261670735869299181":{"error_kind":"string","string":"data length is too long"}}},"bytecode":"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KdC4XIHGFQo0rlSgcZUCjasVaFyjQONaBRrXKdC4XoHGDQo0blSgsVyBxgoFGitBja625omtB633+ro7//f0BgUaJynQeKMCjTcp0HizAo23KNB4qwKNtynQOFmBxtsVaLxDgcY7FWi8S4HGuxVovEeBxnsVaLxPgcb7FWh8QIHGBxVofEiBxocVaJyiQOMjCjQ+qkDjYwo0Pq5A4xMKND6pQONTCjQ+rUDjMwo0TlWgcZoCjdNBja62Homth303vnNqtO/GGY323Tij0b4bZzTad+OMRvtunNFo340zGu27cUajfTfOaLTvxhmN9t04o9G+G2c02nfjjEb7bpzRaN+NMxrtu3FGo303zmiM27vxRGDYde26dl27rl3XrmvXtevade26dl277n87wn5XTBr7NZIvRngeSgY+nrk9ayW3/Z+l9jsP3O/C7VqrbJtDar8fgvv9TMF+vwX3+4uC/S4H97tOwX43gftNr7fz77d2PW6/DRXstzG43yYK9tsC3G+Ggv1mg/ttq2C/ncD99lSw36PA/Z6oYL9ngPstVbDfC8D9DlCw3+Hgfsco2O9EcL+TFOx3MrjfexXsdwq436d8a0X9HcY74vfibuLWEvv76c0KNP6hQOOfCjS6C+7sGqso0JimQGO6Ao1VFWispkBjdQUaayjQWFOBxloKNNZWoLGOAo11FWisB2rcEUzessXO/z3NUKCxlQKNrRVodBRoTCrQmKlAY5YCjdkKNOYo0JirQGOeAo35CjQWKNDYRoHGtgo0tlOgsT2o0TL5vzRaJmc0WiZnNFomZzRaJmc0WiZnNFomZzRaJmc0WiZnNNJMvkXjFjZfenAisczEchMrTKw0scrEahNrTKw1sc7EehMbTGw0UW6iwkSliU0mNpv45yXubtRN/O+jA7gRezm1vZya0mgvp2Y02supGY32cmpGo72cmtFoL6dmNNrLqRmN9nJqRqO9nNpewOFEHFIa7QUcjEZ7AQej0V7AwWi0F3AwGu0FHIxGewEHo9FewMFotBdwMBrtBRyMRnsBB6PRXsDBaLQXcDAa7QUcjEZ7AQej0V7AwWi0F3AwGu3l1PbduBNxSGm078YZjfbdOKPRvhtnNNp344xG+26c0WjfjTMa7btxRqN9N85otO/GGY323Tij0b4bZzTad+OMRvtunNFo340zGu27cUajfTfOaLSX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","debug_symbols":"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D1Vjq+GhashUM1KNrYaHqrHV8FA1thoeqsZWw0PV2Gp4pBq7i26sGlsND1Vjq+Ghamw1PFQNmWpGqrHV8FA1thoeqsZWw0PV2Gp4qBpbDY9UY3fRjVVjq+Ghamw1PFSNrYaHqiFTzUg1thoeqsZWw0PV2Gp4qBpbDQ9Vc6HVcG0nV9+I+dvB041iCP7h4dz72yG6U+0hxsI87mo5kXh3fzj90vqVrrnD0XpN6fZ0LaGj9Qut4YG0fmrEt0eNnFq/UHqgyNYvlHkosnUyrW+w9QvlS4ps/UKpmCJbv1CWp8jWL5RAKrJ1y0032PqVLp3UY+tXus9Ska1bbrrD1i033WHrZFrfYOuWm+6wdctNd9i65aY7bN1y0x22brnpBlu/0hWwemz9SrfLKrJ1y0132LrlpjtsnUzrG2zdctMdtm656Q5bt9x0h61bbrrD1i033WDrV7qQWY+tX+muZ0W2brnpDlu33HSHrZNpfYOtW266w9YtN91h65ab7rB1y0132LrlputtvV7penQ1tl6vdPO6Ilu33HSHrVtuusPWybS+wdYtN91h65ab7rB1y0132Lrlpjts3XLTDbbuLTfdYOvectMdtm656Q5bt9x0h62TaX2DrVtuusPWLTfdYeuWm+6wdctNd9i65aYbbD1YbrrB1oPlpjts3XLTHbZuuekOWyfT+gZbt9x0h61bbrrD1i033WHrlpvusHXLTTfYerTcdIOtR8tNd9i65aY7bN1y0x22Tqb1DbZuuekOW7fcdIetW266w9YtN91h65abbrB1stx0g62T5aY7bN1y0x22brnpDlsn0/oGW7fcdIetW266w9YtN91h65ab7rB1y0032Hqy3HSDrSfLTXfYuuWmO2zdctMdtk6m9Q22brnpDlu33HSHrVtuusPWLTfdYeuWm26w9Wy56QZbz5ab7rB1y0132LrlpjtsnUzrG2zdctMdtm656Q5bt9x0h61bbrrD1i033WDrxXLTDbZeLDfdYeuWm/6XDbZuuel/2WDrZFrfYOuWm+6wdctNd9i65aY7bN1y0x22brnpBluvlptusPVquekOW7fcdIetW266w9bJtL7B1i033WHrlpvusHXLTXfYuuWmO2zdctMNtt4sN91g681y0x22brnpDlu33HSHrZNpfYOtW266w9YtN91h65ab7rB1y0132LrlputtvTnLTdfb+sHLtL7B1i033WHrlpvusHUyrW+wdctNd9i65aY7bN1y0x22brnpDlu33HSDrXvLTTfYurfcdIetW266w9YtN91h62Ra32DrlpvusHXLTXfYuuWmO2zdctMdtm656QZbD5abbrD1YLnpDlu33HSHrVtuusPWybS+wdYtN91h65ab7rB1y0132Lrlpjts3XLTDbYeLTfdYOvRctMdtm656Q5bt9x0h62TaX2DrVtuusPWLTfdYeuWm+6wdctNd9i65aYbbJ0sN91g62S56Q5bt9x0h61bbrrD1sm0vsHWLTfdYeuWm+6wdctNd9i65aY7bN1y0w22niw33WDryXLTHbZuuekOW7fcdIetk2l9g61bbrrD1i033WHrlpvusHXLTXfYuuWmG2w9W266wdaz5aY7bN1y0x22brnpDlsn0/oGW7fcdIetW266w9YtN91h65ab7rB1y0032Hqx3HSDrRfLTXfYuuWmO2zdctMdtk6m9Q22brnpDlu33HSHrVtuusPWLTfdYeuWm26w9Wq56QZbr5ab7rB1y0132LrlpjtsnUzrG2zdctMdtm656Q5bt9x0h61bbrrD1i033WDrzXLTDbbeLDfdYeuWm+6wdctNd9g6mdY32Lrlpjts3XLTHbZuuekOW7fcdIetW2663NaDc5abLrf1Q+uWm+6wdctNd9i65aY7bJ1M6xts3XLTHbZuuekOW7fcdIetW266w9YtN91g695y0w227i033WHrlpvusHXLTXfYOpnWN9i65aY7bN1y0x22brnpDlu33HSHrVtuusHWg+WmG2w9WG66w9YtN91h65ab7rB1Mq1vsHXLTXfYuuWmO2zdctMdtm656Q5bt9x0g61Hy0032Hq03HSHrVtuusPWLTfdYetkWt9g65ab7rB1y0132Lrlpjts3XLTHbZuuekGWyfLTTfYOlluusPWLTfdYeuWm+6wdTKtb7B1y0132Lrlpjts3XLTHbZuuekOW7fcdIOtJ8tNN9h6stx0h61bbrrD1i033WHrZFrfYOuWm+6wdctNd9i65aY7bN1y0x22brnpBlvPlptusPVsuekOW7fcdIetW266w9bJtL7B1i033WHrlpvusHXLTXfYuuWmO2zdctMNtl4sN91g68Vy0x22brnpDlu33HSHrZNpfYOtW266w9YtN91h65ab7rB1y0132LrlphtsvVpuusHWq+WmO2zdctMdtm656Q5bJ9P6Blu33HSHrVtuusPWLTfdYeuWm+6wdctNN9h6s9x0g603y0132Lrlpjts3XLTHbZOpvUNtm656Q5bt9x0h61bbrrD1i033WHrlpuut3XvLDddb+veWW66w9YtN91h65ab7rB1Mq1vsHXLTXfYuuWmO2zdctMdtm656Q5bt9x0g617y0032Lq33HSHrVtuusPWLTfdYetkWt9g65ab7rB1y0132Lrlpjts3XLTHbZuuekGWw+Wm26w9WC56Q5bt9x0h61bbrrD1sm0vsHWLTfdYeuWm+6wdctNd9i65aY7bN1y0w22Hi033WDr0XLTHbZuuekOW7fcdIetk2l9g61bbrrD1i033WHrlpvusHXLTXfYuuWmG2ydLDfdYOtkuekOW7fcdIetW266w9bJtL7B1i033WHrlpvusHXLTXfYuuWmO2zdctMNtp4sN91g68ly0x22brnpDlu33HSHrZNpfYOtW266w9YtN91h65ab7rB1y0132LrlphtsPVtuusHWs+WmO2zdctMdtm656Q5bJ9P6Blu33HSHrVtuusPWLTfdYeuWm+6wdctNN9h6sdx0g60Xy0132Lrlpjts3XLTHbZOpvUNtm656Q5bt9x0h61bbrrD1i033WHrlptusPVquekGW6+Wm+6wdctNd9i65aY7bJ1M6xts3XLTHbZuuekOW7fcdIetW266w9YtN91g681y0w223iw33WHrlpvusHXLTXfYOpnWN9i65aY7bN1y0x22brnpDlu33HSHrVtuut7Wg7PcdL2tB2e56Q5bt9x0h61bbrrD1sm0vsHWLTfdYeuWm+6wdctNd9i65aY7bN1y0w227i033WDr3nLTHbZuuekOW7fcdIetk2l9g61bbrrD1i033WHrlpvusHXLTXfYuuWmG2w9WG66wdaD5aY7bN1yU3mtH3WWm0a+Otx3tG656Q9oPaR2/u1H9Z1aJ9P6G1rPPp0+IwfnHx//pUhLN4UUaRmkkCItKRRSpOV5Qoq01E1GkdGyMSFFWoIlpEjLmYQUaWmQkCLJFCmjSMtshBRpmY2QIi2zEVKkZTZCirTMRkaRZJmNkCItsxFSpGU2Qoq0zEZIkWSKlFGkZTZCirTMRkiRltkIKdIyGyFFWmYjo8hkmY2QIi2zEVKkZTZCirTMRkiR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O+WR2Dvlkdg75ZHYO+WR2Dvlkdg75ZHYO+2R2GuPxF57JPbaI7HXHonXt2SRJqA9Envtkdhrj8ReeyT22iNx0B6Jg/ZIHLRH4qA9Eq9vySJNQHskDtojcdAeiYP2SBy0R+KoPRJH7ZE4ao/EUXskXt+SRZqA9kgctUfiqD0SR+2ROGqPxKQ9EpP2SEzaIzFpj8TrO1tJE9AeiUl7JIbvscUS0B6J8XtsMQTwe2xxBLRHYvweWxwB7ZEYv8cWR0B7JNbeY8tr77HltffY8tp7bHntPba89h5bXnuPLa+9x5bX3mPLa++x5bX32PLae2x57T22vPYeW157jy2vvceW195jy2vvseW199jy2ntsee09trz2Hltee48tr73HltfeY8tr77HltffY8tp7bHntPba89h5bXnuPLa+9x5bX3mPLa++x5bX32PLae2x57T22vPYeW157jy2vvceW195jy2vvseW199jy2ntsBe09toL2HltBe4+toL3HVnDKI3HQ3mMraO+xFbT32Arae2wF7T22gvYeW0F7j62gvcdW0N5jK2jvsRW099gK2ntsBe09toL2HltBe4+toL3HVtDeYyto77EVtPfYCtp7bAXtPbaC9h5bQXuPraC9x1bQ3mMraO+xFbT32Arae2wF7T22gvYeW0F7j62gvcdW0N5jK2jvsRW099gK2ntsBe09toL2HltBe4+toL3HVtDeYyto77EVtPfYCtp7bAXtPbaC9h5bQXuPraC9x1bQ3mMraO+xFbT32Arae2wF7T22gvYeW0F7j62gvcdW0N5jK2jvsRW099gK2ntsBe09toL2HltBe4+toL3HVtDeYyto77EVtPfYCtp7bAXtPbaC9h5bQXuPraC9x1aA7y9EId0IUA4dAuhzIKd8I5BL6hCAmgPfkKCs+hsS1IrxGxLUGvAbEtSq7i9IWH1fviGt93mp3v52zd4xLiPVWH49ffyszy5jQycXYQJROwHSTiBpJ5C1EyjaCVTtBJpuAnFDJxdhAsojcXTKI3F0yiNxdMojcXTKI3F0yiNxdMojcfTwcaDGG4HmQocAuhdqvp4EQukQgPJC35Cg/Mo3JChP8Q1p/dwv5SxPlNqDVPEgNThIGzo2sJA8HqSAByniQSI8SAkPUsaDhOe9A573DnjeO+J574jnvSOe94543nvDWe1aww3Skdo8Q1p/8rR5f/tO3nzoaGn9ScaW3C1tbYlSB9LyGNdycDdIOf8Oqfe3283yYnHuOetbfzZRmkDRTqBqJ9CUE1h/NlGagNdOIGgnELUTIO0EtEfipD0SJ+2ROGmPxEl7JM7aI3HWHomz9kictUfi9WcTpQmgx4FC8STwuLn2RqCge6GjnnT72633BgqUF/qGBOVXviFBeYpvSOvnfom3sx2tJP9P5/7601DSBLJ2AkU7gaqdQFNOoDrtBLx2AkE7gaidgPZIXLVH4qo9Elftkbhqj8RVeyRu2iNx0x6Jm/ZI3LRH4oYeB7hyUkP3Qkw5iRyUF/qGBOVXviFBeYpvSBvm/nlYoVUfGcs7LOy24+v4mTuWR9oJJO0EsnYCRTuBqp1AU07AO+0EvHYCQTsB7ZF4/elQaQLaI7HXHom99kjstUdirz0SB+2ROGiPxEF7JA7okTjUk0CoPQLokZglgB6JOQIR3QtFdyup+hioQwB9DlC77ZPyyaUOAag58A0Jyqq/IUGtGL8hQa0BvyFBreq+IUGt0/6CtP4m3db8zYu1FjPnMpx3p89w3j9/h6ENJ5rFKQT9FKJ+CqSfQtJPIaunkMA9Ug5n+4McQugQAJ8JOVA9CZTeGwCfBzwB8FnAEyjaCVR0Au2GJEfXI9CUE8jga1OeAHwc4AiAr0t5AuCrUp4AfCTmCKBH4nhfC8XeWiijR2KWAHokZgmgR2KWAHok5ggU9EjMEkCPxCwBTZG4SwA+Dpx/O5OvHQLwcYAjAB8HOALwbpQhsP4A7lGqSnQWq1zhzgzklG+EcyqtQ8HrpxD0U0B3pimFk0DufOit6M6UJYDuTFkC6IvqRwK9OdDgl3RMNGhQb+Ab0oYIex5SOzyjI0ap3DawtOFMmzQDr55BUM8gqmdA6hkk9QyyegZFPYOqnoH6mOzVx2SvPiZ79THZq4/JG87aSTNQH5O9+pjs1cdkrz4me/iYzJx1SQE+JrMM4GMyywA+HjAHjlKA90XMiaMUsHzRNyYs7/IXpojlL74xYXmAb0w7Pi75h49LbF26lXp7/PjZmRLrTxHKUyD9FBI8hXq/17GG2qGQ9VMo+ilUVRRi6FBo6imQ00/B66eAH51rOq8Sqal1KOBHZ5YCfnS+36LcaosdCgqic7nPhdbJ3UhBdOYoKIjOHAUF0ZmjgB+dmzsX282XZwoJPzqzFPCjM0sBPzqzFPCjM0sBPzqzFPCjM0sBPzqzFBTEBTobrbfsnylksOn8DWrHBP2j/et8i4yU0xVI5CuQKFcgUa9Aol2ARME/XcN0v0kF3jdxzUtSgfdMPAV4v8RTgPdKPAV4n8R1oEgKTl2yFPBPXbIUFMQFjkLUT4H0U1AQnTkK+NGZ6UeRKn50ZingR2eWAn505ig0/OjMUsCPziwF/OjMUtAVnbsUFMSF14faU1MQFzgKCuLCawrZKXCqHAX86cy02MiO9FPAX2yzFPCdKtPqJDsFyzxmOnuwufANaoN1ex/uBfTYGL1yJ9Gyz/opFP0Uqn4KTT2F4PRT8PopBP0Uon4KpJ+C/ugc9EfnoD86B/3ROeiPzlF/dI76o3PUH52j/ui843yyNAX86Mz038gRPzqzFPCjM0eB8OMC0wYlE75HYvqgZALzSN+gwHzMNygwr/ENCswPfIPase6mdgfFlq25Lhx5x9lGYQo7zjZKU/DwFJguHHnH2UZpClE/BVJFodPCIu842yhNIeunUPRTwI/OTCORnPCjM0ch40dnphdKzgqi8+sWFjkriM4cBQXRmaOgIDpzFPCjM3NsP2f86MxSwI/OLAX86MxSwI/OHIWCH51ZCvjRmaWAH51ZCgriwuteKLmATee/QO042+vrHVRwXI8ZvmVC3nG6V55EuAKJeAUSdAUS6QokKjoJrhdKbvC+iWthkRu8Z+IpwPslngK8V+IpwPskrvNA3nHCVJpC0U9BQVzgKDTtFIqDzx14CgqiM0cBPzoznQeKw4/OLAX86MxSwI/OLAX86MxSwI/OLAX86MxS0BWdexS8grjw+sx78QriAkdBQVzgKChwqhwF/OnMdOEoAX+xzVLAX2yzFPCdKtMLpQQFyzxmOkewufANaoN1B7rfphrKP72Vu+w42yhNIeqnQPopJP0Usn4KRT+Fqp9CU09hxwlTaQr6ozPpj86kPzrvOOcrTUF/dCb90Zn0R2fSH51Jf3RO+qNzwo/OTBeOkvCjM0sBPzqzFPDjAtMLpSR8j8T0QikZzCN9gwLzMd+gwLzGNygwP/ANijaAqvf+15EtW3NdOMqOs43SFLJ+CgWeAtOFo+w42yhNoamnsONs4z+g0GlhUXacbZSmEPRTiPop4EdnppFIKfjRmaWAH52ZXiilKIjOr1tYlKIgOnMUFERnhkJVEJ05CvjRmTm2Xyp+dGYp4EdnlgJ+dGYp4EdnlgJ+dGYp4EdnlgJ+dOYoNAVx4XUvlNLApvM3qA0TNJK/g8qV0Wv0/qbX42fPNIp+ClU/haadQt1xtleagtdPIeinEPVTIP0Ukn4K6qNzdeqjc3Xqo3N1+qOz1x+dvf7o7PVHZ68gLpx7B2Nv72D1+B4p+NvjMQTXoQDmkf4CFcB8zDcoMK/xDQrMD3yD2rHubvcKCz32pJhzTjuuYJamkPRTyPopFP0Uqn4KTT2FHY0HpCl4/RSCfgr6o/OONgXSFPRH56g/Okf90Tnqj85Rf3QmBXGBKWYQvkfiihkE5pG+QYH5mG9QYF7jG9QP+4G/hPz0keVvIX6FkLBCSFwhhFYISSuE5BVCygohdYWQFTM+r5jxf37E93tYmBsW54bR3LA0NyzPDStzw+rcsDY17M8P4H0Pm7OSMmclO05GCS9Ki4JFabwvSmOPAn6azFLAT5NZCvhpMksBP03mKFT8IjZLAb+IzVLAL1awFPCL2CHEO4VOyWjHyShpCgqiM0dBQXTmKCiIzhwFBdGZo6AgOjMUmoLo/ECBOnGhKYjO6fzrIffegoLozFFQEJ05CgqiM0dBQXQ+u4ocFGqHgoLozFFQEJ05CgqiM0dBQXR+TaE5BdGZo6AhOjMUNETnO4VSOhQ0ROc7heY6FBRE54eVavMdCuq3WzSnIDpzFBREZ46CgujMUVAQnRkKXkF05igoiM4cBQXRmaOgIDpzFBREZ46C/ujs9Udnrz86ox1l7fx1Zg9GQzv4+uefCxvaMdkZCvjNbFgKpJ8CftMClgJ+MxuWAn4zG5aCgtYRHAX8ZjbMF88W8aMzS0FBdOYoKIjOHAUF0ZmjoCA6cxQURGeOgoLo/HoPRosKovPrT+ctKojOHAUF0ZmhQAqiM0dBQXRmvniSgujMUVAQnTkKCqIzR0FBdOYoKIjOHAUN0ZmhoCE6v96DQRqi8+s9GElX7tzbg5EURGfm+0JSEJ05CgqiM0dBQXTmKCiIzhwFBdGZo6AgOnMU1DdFbklBdGYoZAXRmaOgPzpn/dE564/OCm6OZy4tawpujm/nNhLvnOukbQqujuc54N9Oy3JQcHk8z0HBPYQsBwUX1LIcFNxQy3KgC3BQcEftIwff+W6o4Ap5noOyON3loCxOdznAx+kDeKx3EtQpEuPfI/8OCfhIfQAv9+ddTR0S8KH6AJ7LA4nOnMC/Tf4dEvDB+h0S8NH6HRLw4dq7A/r5vPexQwI+Xr9DAj5gv0NCQcRmSTQFEZsnoSBi8yQURGyehIKIzZNQELF5EgoiNk/iChG7XSFiN/0RO7od3XwC3VeloRBHIp57mHzMrkMh6KcQ9VMg/RSSfgpZP4Win0LVT6GpolDCM4Ud3XykKeiKzl0KuqJzl4KC6FzySaG2DgUF0ZmjoCA6cxQURGeOgoLozFFQEJ05CgqiM0MhKIjO1F5TUBCd6fyyG1vpUMCPzhTC7XGK1KGAH53pxOIp+Q4F/OjMUsCPziwF/OjMUsCPzo8Ucm8640dnlgJ+dOYoRPzozFLAj86PFEruUNAQnRkKuqJzl4Ku6NyloCs6dykoiM7trCMllzoUFERnjoKC6MxRUBCdGQqkIDpzFBREZ46CgujMUVAQnTkKCqIzR0FBdOYo6I/OpD86k/7oTPqj845uPr62OwV2X1gO7YYlx9D54rmjj4y/V9uPr0yeocActj8oZHwKrw+EHhzKBTjUC3Bo+jns6CUjzsFfgEO4AId4AQ6ki4Pv1MSygjDNclAWp7sclMXpLgf4OM2eUz9IwAfqN0gU+EjNHrY/SMCHavZ09EECPla/QwI+WL9DAj5av0MCPly/cWCswMfrd0jAB+x3SCiI2DwJBRGbJVEVRGyehIKIzZNQELF5EgoiNk9CQcTmSVwhYtcrROx6hYi9o7OM9+EOKjaOBHcudEdfGWkKQT+FqJ8C6aeQ9FPI+ikU/RSqKgq9M9KtaadwRG/9FHRF5y4FBdH59dFW7xREZ46CgujMUVAQnTkKCqIzR0FBdOYoKIjOHAUF0fn1YXvvFUTn14ftvcePzsxhe+/xozNzRtp7/OjMUsCPziwF/OjMUsCPzswZae/xozNLAT86sxTwozNHIeBHZ+aAsQ8aojNDQVd07lLQFZ27FHRF5y4FBdH59SksHxREZ46CgujMUVAQnTkKCqIzQyEqiM4cBQXRmaOgIDpzFBREZ46CgujMUdAfnaP+6Bz1R+eoPzrv6CPj0sPhF3ZfGHfY3u/oYOL8A4X4D2+2PygkfArMgVC/o4WJOIdyAQ71Ahyafg7JXYCDvwCHcAEOUReHzgFpnxSEaZaDsjjd5aAsTnc5wMdp/py6T/CB+h0S8JGaP2zvM3yo5k9H+wwfq98hAR+s3yEBH63fIQEfrvkDYz7Dx+t3SMAH7HdIKIjYPAkFEZsnoSBisySKgojNk1AQsXkSCiI2T0JBxOZJXCFilytE7HKFiL2+s0xr5WFR6v7pHcx+fVsZcQZePYOgnkFUz4DUM0jqGWT1DIomBr2j0bWqZ6AqJvcYNFUxucsAPyYzp1kbfkzmGODHZI4BfkzmGODHZI4BfkzmGODHZI4BfkxmDtY3/Jj8+lx9cPAxmTlWHxx8TGYOQwcHH5NZBvAxmWUAH5NZBvAxmTkIHRx8TGYZwMdklgF8TGYZwMdk5gRx8ApiMsNAVUzuMlAVk7sMVMXkLgP8mPz6hFXw+DGZY4AfkzkG+DGZY4AfkzkG+DGZYRDwYzLHAD8mcwzwYzLHAD8mcwzUx+SgPiYH9TE5qI/JcUM88LdidGvsJi/u5HxY346klXr7260+7jqb2pMQ1jcjkSaQtBPI2gkU7QSqdgJNOQFy2gl4RQQ6e3ICBe0ENEXiLgFNkbhLAD4Sv95JEQg+EnME4CMxRwA+EnME4CMxQyDBR2KOAHwk5gjAR+LX27lCgo/EzG6u9X12/pAAt5kroUdibhdOQo/ELAH0SMwSQI/ELAH0SMztwMnokZglgB6JWQLokZglgB6Jub0r61voSBPQFIm7BDRF4i4BTZG4SwA+EjMf+TJ8JGYIFPhIzBGAj8QcAfhIzBGAj8QcAfhIzBGAj8QcAfhIzBGAj8QcAe2RuGiPxFV7JK7aI/GGTjglnld/lMTddRJrcOffDp2ceEMjHGECWTuBop1A1U6gKSewoQeOMAEPTqA0uhP4PQ48P33UKG4fpI5k+XF7VA9JCOG2iTiEmH57+ls5wZQzVk405YyVQ5+snHQ+fWS7HeWgr3y2Kgd9VbVVOegrtq3KQV8N/qhy2m0vUIjed5SDvtL8WeXQXTnhSTnRoa9if1Y58VROJ5RH99Er5HY+HSl2lPPRK2ROOR+9QuaUQ3qV800Avn53rheOn6VDAL5+xxGAr99xBODrdxwB+PodQ8DD1+84AuirE5YA+gqCJYAe5WtsdwK1QwA9ErME4CMxRwA+EnME4CMxRwA+EnME4CMxQyDAR2KOAHwk5gjAR2KOgPZIvKEb1x8SaPevya11CMBHYo4AfCTmCMBHYo4AfCQ+O4/F5lyHAHwkZghE+EjMEYCPxBwB+EjMEYCPxBwB+EjMEYCPxBwB+EjMEYCPxBwB7ZE4ao/EpD0Sb+iFls8Nry3nxBJ4vT02buiFJkwgaSeQtRMo2glU7QSacgIbeqH9GYGNW63jhj5ripQTTDlj5aCvTjbuJo4bes8pUg76qmqrctBXbFuVg74a3LhJPyb0lebOTfoJfRW7c5N+/ugVMrPVOn/0CplTzkevkDnlKF4hfxMg9NSf2V2a4et3HAH4+h1HAL5+xxGAr99xBODrdwyBgr46YQmgryBYAuhRntsaWOC/pHEE4CMxRwA+EnME4CMxRwA+EnME4CMxRwA+EjMEKnwk5gjAR2KOgPZIXOEjMbPDekPnTGEC8JGYIwAfiTkC8JGY2ZhW4SMxRwA+EjMEGnwk5gjAR2KOAHwk5gjAR2KOAHwk5gjAR2KOAHwk5ghoj8RNeyRuyiMxbejh5n26EfDB/UbgG9J6z+7L7UtiC652IBEepIQHKeNBKniQKh6kBgdpQ28uT+UOqTGO1ady3n6c6u97Lb4JeO0EAjiB7G5IfPalQyDCEzhvucnRdwgQOoFUTwI5dwgk7QSydgIFnkA5CXS9UNVOoCknENAjMUsAPRLnlE8CrUcAPRKXcC4lCnUicUCPxMWV1wTQI3HJ6SRQO0uJgB6JS77lA7466hBYH4mDbyeBFJ9TlA3dtlhIFQ9Sg4O0occVC8njQQp4kCIeJMKDlPAg4XnviOe9N/RconJ7ulHtQWpwkDb0RWIheTxIYSuk5juQ1vuldK7rW6LUgZTxIBU8SBUPUoODtKFPDwvJ40EKWyGljl/a0AmG1RLhQcLz3gnPeyc8753wvHfC894Zz3tnPO+dAx4kPO+d8bx3xnOV6w9213ZCqs3nZ0jrj2rzkDwepIAHab0TcOfuk+Z8Z1W54cgzCynhQcp4kAoepIoHqcFBqnh+af1hxdpiOCGVzu7q9YffeC1tWAmcn5uPn+0ZUnN4kDwepIAHKcLNuPUHvXhIeH5p/WEsHlLBg1TxIDU0SMlt8N7l7pda7UDyeJACHqSIB4nwICU8SBkPUtkIqZuhJLfTew8g4Xlv7/AgeTxIAQ8S3No7ecKDBLf2Th5u7Z083No7ebi1d/J43jvgee+A573XHyipqd7+ds3+d0jPT6dab3cupOYeL6RovwgkcALHR8eTQGodAlk7gaKdQNVOoCknsP4gjDQBr51A0E4gohOgfBLIrkMAPRKzBOAjMUcAPhJzBOAjMUcAPhJzBOAjMUOA4CPxI4FOHCD4SHw+nVrrvQH4SMwRgI/EHAH4SMwRgI/E5Z7UP57QOwnAR2KOAHwk5gjAR2KOAHwkZggk+EjMEYCPxBwB+Eh8Esiu01M3JfhI/EAgdIq7648fTq9GDwKxQwA+Evt6zoFQOgTgIzFHAD4ScwTgIzFHAD4SMwQyfCTmCMBHYo4AfCTmCMBHYo4AfCTmCGiPxFl7JM7aI/GGU7mBbp26asiRIVDSeTCtpN5yesMZXmECQTuBqJ0AgROg89LAg0AnI1t/9liaQNZOoGgnULUTaMoJVPRIzBJAj8QsAfhInNJJoFCHAHwkjuUkkDqReP0FytIE0CMxSwA9ErME0CMxSwA9ErME0CMxR6DB58QcAficmCMAH4k5Atoj8Ya+Gn9G4Kh93Qjk2FkLNfRInF07CVDvDaBH4pzvBHqr0YYeiVkC6JGYJYAeiRkC2aFH4ny25S+5lQ4B9EjMEkCPxCwB9EjMEoCPxBwB+EjMEYCPxBwB+Eh8J1Bc6xCAj8QcAfhIzBDwiiJxnwB8JD4vKj24pA4B+EjMEYCPxBwB+EjMEYCPxBwB+EjMEYCPxBwB+EjMEYCPxAyBAB+JOQLaI3HQHomD9ki8vr9QCfdv76EkhkCswZ1/O3QKW+v7C0kTqNoJNOUE1vcXkibgtRMI2glEcAKl0Z3A73Hg+emQ660vYCi/HR3tIQkh3L6AhhDTb09/K4dMOWPlJFPOWDnoq5MfVU46n/4Nyakc9JXPVuWgr6q2Kgd9xbZTOYS+GvxR5bRbchniYx/+UznoK82fVQ7dlRM6ykFfxf6scuKpnF4op49eIbfz6Uixoxwy5YyV89ErZE45ilfI3wTg63fneuH42dkSQvD1O44AfP2OIZDg63ccAfj6HUcAvn7HEUBfnbAESDsB9ChfY7sTqB0C8F/SOALwkZgjAB+JOQLwkZghkOEjMUcAPhJzBOAjMUcAPhJzBOAjMUdAeyTO8JG43b8mt84O6wwfiTkC8JGYIwAfiRkCBT4Sl9un39g63alzgY/EHAH4SMwRgI/EHAH4SMwRgI/EHAH4SMwRgI/EHAH4SMwRgI/EDIGqPRJX7ZG4ao/E63uhFX/vJxF84QgEf6Mbw2/bY399pVzfC+1PCSR/Eii/73t5ftqncqtl+1Rdh275LLr1UnTz2eTY58e/fdJtF6PrTrqxs+VrfQ+3n6Wb6kk35w5d/1l0w2fRjRejW066Pc+8vvfcXrrw6yRZutdaVbF0r7Wqup/MPaT06F5rVVXCuYgs1FlVtWutqoorr+gWd61VVcnppFt9h+61VlUl3za1+uqoQ1fxquqbAPw66dxFHUNLHQKknQD8WoYjAL864QjArzc4AvArCI4A/JqAIeDhozxHAD5ucwTgIzFHQHskXt/rT5oAeiSO4Xb08vhZOwTQIzFLAD0SswTQIzFLAD0SR1/uBNozgYAeiVkC6JGYJYAeiVkC6JGYJYAeiVkC8JGYIwAfiR8IxE5hK8BHYo4AfCRmCGzo9edPSEc65X8j8A0p4EGKeJAID1LCg5TxIBU4SBt6VLl6++Rx/EwdSBtm3Llz6VBY7EDKeFraYEvubkuPXatOSBUPUoODtKHHCAvJw824DX1AWEh4fmlDrw4WUsKDlPEgFTxIG7x3OGOcj6UDqcFB2tCXgoXk8SAFPEgRDxLhQdqbx3Uh7fXeXUh43jtXPEgNDlJxeJDw1t4Fb+1d8NbeG3oCsJDw1t4Fb+1d8Lx3wfPeBc97y5y+DieknBv3NHMcudS4HpLkidtSSTuBBE6AOQRcZE60/yiBl8d6i8wZ9Z8k8PooZ5E5db6TQFNOQOZk+I8SeHmisMic9d5JIGgngB6JWQLokZg5ZloaeiRmDo6Whh6JuaOgDT0Sc4c7G3ok5o5rNqhI/AWpug2x9fU5iOo8HqSAByniQSI8SAkPUsaDVPAgVTxIDQ6Sx/PeHs97+/XemznnVH3Eg0R4kBIepPXemznsUX3Bg1TxIDU4SMHhQfJ4kAIepLgVUue4Tg2EBynhQZLwS6mcX/3SY5nC3YS0BUKiWyHErxASVgiJK4TQCiES0T7RXQjlZyEi535SPktPqXSYiJzkYZmIvJN8F1JcR0haISSvEFJWCKkrrKstEJJWzBOR8zeskLBCSFwhhFYIEZnx5yG+mFpnnoicTGGFlBVC6gohbYEQkRMerBC/Qoj0uqsrRHrGd4WsmPE5rRCSVwgpK4SsiPF5RYwvK2J8WRHjy4oYX1bE+LJixpcVM7789Iw//kVfz/rWvyAsJH8bHHJ7PP5NHVHF0/2IGKXfnj74HEL8CiFhhZC4QgitEJJWCMkrhJQVQuoKIW2BkLZixrcVM76tmPFtxYxvK2Z8WzHj24oZ31bM+LZixrefn/HBObdCiF8hJKwQElcIkZjxwZ9Cgu8JSSuE5BVCygohdYWQtkCIdyuE+BVCwgohcYWQFTPer5jxfsWM9xIzns6DlIWyY55O9SyOHj97kCoepAYHKUj4nni/wjrm0hHiVwgJK4TEFUJohZC0QkheIUTC98R75+X4256Nm5C6QkhbICS6FUL8CiFhhRCRGX9uST6EcE+zPjsSHqSEBynjQSp4kCoepAYHiRweJI8HKayGlI9o9uvp42ftQIp4kAgP0nLvncPZ9ef4mTuQMh6kAgcprbelEOmEFDtOIFU8SG09pBxPSL+defgFKTs8SB4PUsCDFPEgER6khAcJL6BkvICSKx6kthdSx5aKw4Pk8SAFPEgRDxLhQUp4kPLWgNKFtMF7p/tC92+ffr4hVTxIDQ5SdXiQPB6kgAcp4kEiPEgJD1LGg4TnvSue96543rutn3FH7niWT3sfoBvei2s//OK+hHjnVgjxK4SIBLv7HqkYXEdIXCGEVghJK4TkFULKCiF1hZC2QIjITlVWiMSMp3jOeOrs6PYiO1VZIXGFEFohJK0QklcIEdmpSueVdpRaR0hdIaQtECKyP5QV4lcICSuEiMx4yR2+XmQ3qTCkhAcp40GC21PvA9yeeh/g9tR7kR22wpA8HqSwGhK3D8rHiAeJ8CAt997cN2IfMx6kAgeJ1s84ZmuWp4wHacOLe713xVPFg9TgICWHB8njQQp4kCIeJILz3gkv7Ca8sJs2h92eLVU8SA0OUnZ4kDwepIAHKeJBoq0BpQtpg/d+/Y3Y54wHqeBBqniQGhyk4vAgeTxIAQ9SxINEeJDwvHfB894Fz3vXDUXm17vFfMV7cfWHX9y3kLpCSFsgRKQna2y3Nezxs1NlF+nJygoJK4TEFUJohZC0QkheIaSsECIy49vZ/SklYp5mPzqK7IsVhRREdtEKQ/J4kAIepIgHifAgJTxIGQ9SwYME572Dw/PeHs97ezzv7fG8t8fz3h7Pe3s87+3xvLfH895+uffm9o0F3+AgBYcHabn35r6phxDwIEU8SOtnHLOVLcSAB2nDi3u91yfIbLGVhZTwIGU8SAUPUsWD1OAgkYPz3oQXdgkv7NLmsNuzJcKDlPAgZTxIBQ9SxYPU4CAltzWgdCFt8N6vv6mHFPAgRTxIhAcp4UHKeJAKHqSKB6nBQcoODxKe98543jvjee+8ocj8enddKHgvrvzwi/sWQiuEpBVCJIJdehDSOomsyFZVVkhdIaQtECLSMpcV4lcICSuExBVCaIWQtELIihlfV8z4umLG1xUzvq2Y8W3FjG8rZrzIzuB871KaQycyiuynLfX2/fn42Sml/PkO2a9h8c93sX4P83PDwtywODeM5ob1baKcX0iPn6kzLM8NK3PD6tywNjVssFuOHebnhoW5YXFuGM0Nm7MSP2clfs5K/JyV+DkrCXNWEuasZLC7pbRzdtdYGK96vMVbfDh+PsQHX38JiSuE0AohaYWQvEJIWSGkrhDSFggZdDUUFuJXCFkx4+OKGR9XzPi4YsbHFTM+rpjxccWMjyIzvtZTSOsIIbdCiF8hJKwQElcIoRVCJKwr+NOEw2M2exOSJN7JsaC9CTmcYUeIxDuJxZ9Cmv9NyPPTPp3bJ3yqrgOJ8CCl5ZDyecbeZ186kPIGSO6EFH0HUlkPKdUTUu5M1FTxIDU4SNltgFROSL0Zlz0epIAHKeJBog2Q8gmp9SCt994lnAGlUMd75/Xeu7jyGtJ6711yOiHVTkDJdQOkWzHMV9dZL+Uf9t5/CSkS/vjepOdY3YeOEL9CSFghJK4QQiuEpBVC8gohZYUQCf9ARKeQ1JuMbYGQ6lYI8SuE/PGM/x4W54bR3LA0NyzPDStzw/rW3dI5KVxrzOsqLpz3cbnweJq6/BLSFggZ7JUQFuJXCAkrhMQVQmiFkLRCSF4hpKwQsmLGtwUznpxbIcSvEBJWCIkrhNAKISImfH7cKe63DeO/hHiJF+/PambxPnaESLz4oyBxExIeq7iHkD//qEU+4kEiPEgJD1LGg1TwIFU8SA0OUnB4kDweJDzvHfC8d8Dz3gHPewc87x3wvHfA895hg/d+vXOEosOD5PEgBTxIEQ8S4UFa7wSYbVRE682b2XRFtN68RfdDEUXtBAicALP9iyjBE3i5WYwooxN4vWmKqGgnULUTaPAEXu6VouS0E/DaCaBHYpYAeiRmNudRQo/EzFY+SuiRmNn4Rwk9EjPbBCmhR2JmUyElqEj8DWl9bGV2e1F2eJA8HqSAByniQSI8SAkPUsaDtN7XMzseKVc8SA0OUnF4kH7Ye38LCSuExBVCaIUQCS8Y7vuHQkn/D2Mmud0gxeIeM5T2C1LGg1TwIFU8SA0OUnV4kDwepIAHKeJBIjxIeN674nnviue9K573rnjeu+F574bnvRue92543rvhee8G572TW2/eheIJKccOpPUvrpZzP0nraumHX9y3kLxCSFkhRCDY1WO6/Hq6hhyZN1hcvf3t42fovMEGB8m75ZBiOvs7x5o7kDwepIAHKeJBop2QqOczJU4JSUPK6yGdvX9LpNaBVPAgVTxIDQ5ScHiQPB6kgAcp4kEiPEgJDxKe9w543jvgee+A570jnveOeN474nnviOe9I573jnjeO+J574jnvSOe94543pvwvDfheW/C896E570Jz3sTnvcmPO9NeN6b8Lw34XnvhOe9E573TnjeO+F574TnvROe90543jvhee+E570TnvfOeN4743nvjOe9M573znjeO+N574znvTOe98543jvjee+C570LnvcueN674Hnvgue9C573Lnjeu+B574LnvQue96543rviee+K570rnveueN674nnviue9K573rnjeu+J574bnvRue92543rvhee+G570bnvdueN674Xnvhue9G5z3zg7Oe2cH572zg/Pe2cF57+zgvHd2cN47OzjvnR2c984Ozntnh+e9PZ739nje2+N5b4/nvT2e9/Z43hvvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlhnvrGXGO2uZ8c5aZryzlgXvrGXBO2tZ8M5aFryzlsXBee+Cd9ay4J21LHhnLQveWcuCd9ay4J21LHhnLQveWcuCd9ay4J21LHhnLQveWcuCd9ay4J21LHhnLQveWcuCd9ay4J21LHhnLQveWcuCd9ay4J21LHhnLQveWcuCd9ay4J21LHhnLQveWcuC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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"62":{"source":"use jwt::JWT;\n\nglobal MAX_DATA_LENGTH: u32 = 232;\nglobal MAX_NONCE_LENGTH: u32 = 32;\n\n// this circuit is not verifying that the key matches anything\n// the verifier does this (public input to the circuit)\n\n// Trust assumption with google: google is attesting to the fact\n// that the prover has access to a certain top level domain.\n// google is also attesting to the fact\n// if the proof becomes public, Google can figure out who's it is\n// by matching the nonce\n//  - possible to fix using semaphore\n//    - create a group for each domain. prove membership to join group\n//    - google can find out that you joined the group (which they already know)\n//    - they cannot link users to messages like current impl\n//  - do it in Aztec. prove membership and then emit message in public log\n\n// partial hashing\n// stealthnote uses ephemeral\nfn main(\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    pubkey_modulus_limbs: pub [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n    // domain: pub BoundedVec<u8, MAX_DOMAIN_LENGTH>,\n    nonce: pub BoundedVec<u8, MAX_NONCE_LENGTH>,\n) {\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    // Validate key value pair in payload JSON\n    jwt.assert_claim_string(\"nonce\".as_bytes(), nonce);\n}\n","path":"/home/josh/Documents/Github/stealthnote_workshop/circuit/src/main.nr"},"63":{"source":"use base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::RBN2048};\nuse std::hash::sha256_var;\nuse string_search::{StringBody, SubString};\nuse zkemail::partial_hash::partial_sha256_var_end;\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature: RBN2048 = RuntimeBigNum::from_array(params, self.signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            //@safety: extract the value in unconstrained mode, and verify later\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key + a quote - searching for just the key string might return matches from elsewhere in the payload\n        let mut key_with_quote: [u8; KEY_LENGTH + 1] = [0; KEY_LENGTH + 1];\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH] = 34; // ascii for quote\n        let mut needle: SubString<(((KEY_LENGTH + 1) + 31) / 31) * 31, (KEY_LENGTH + 1) / 31, (KEY_LENGTH + 1)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after claim_key is a quote and colon\n        assert(haystack.body[position + KEY_LENGTH + 1] == 58); // :\n\n        let mut value_offset = 0;\n        if (is_value_quoted) {\n            // assert the char before and after the value is a quote\n            assert(haystack.body[position + KEY_LENGTH + 2] == 34); // \"\n            assert(haystack.body[position + KEY_LENGTH + 3 + value.len()] == 34); // \"\n            value_offset = position + KEY_LENGTH + 3; // for two quote and colon\n        } else {\n            // numeric - assert the character after the value is a comma\n            assert(haystack.body[position + KEY_LENGTH + 2 + value.len()] == 44); // ,\n            value_offset = position + KEY_LENGTH + 2; // for a quote and colon\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_offset + i] == value.storage()[i]);\n            }\n        }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 1] = [0; KEY_LENGTH + 1];\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i] = key[i];\n        }\n        key_with_quote[KEY_LENGTH] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 1) + 31) / 31) * 31, (KEY_LENGTH + 1) / 31, (KEY_LENGTH + 1)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 2; // +2 for the quote and colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n","path":"/home/josh/nargo/github.com/zkemail/noir-jwt/v0.4.2/src/lib.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_base64/zw/vector-optimizations/src/boundary_check.nr"},"66":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_base64/zw/vector-optimizations/src/decoder.nr"},"103":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"104":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"106":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/serialization.nr"},"107":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"108":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"110":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/params.nr"},"111":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"118":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"119":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"130":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_rsa/v0.6.0/lib/src/rsa.nr"},"132":{"source":"mod utils;\n\npub use utils::{conditional_select, lt_f, DebugRandomEngine};\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\nfn bug_repr(needle: [u8; 32], needle_len: u32, haystack: [u8; 128]) {\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n\n#[test]\nfn bug_test() {\n    let haystack: [u8; 128] = [\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000029,\n        0x0000000000000000000000000000000000000000000000000000000000000092,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000055,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x000000000000000000000000000000000000000000000000000000000000006e,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000057,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000084,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000004,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x000000000000000000000000000000000000000000000000000000000000005a,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n\n    let needle: [u8; 32] = [\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n    let needle_len: u32 = 0x0000000000000000000000000000000000000000000000000000000000000020;\n    bug_repr(needle, needle_len, haystack);\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_string_search/main/src/lib.nr"},"133":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = dep::std::hash::sha256(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_string_search/main/src/utils.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","get_lt_predicate_f","directive_integer_quotient","directive_invert","directive_to_radix"]}