{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":12368495971301678791,"abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"public"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"nonce","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3951064283418873378":{"error_kind":"fmtstring","length":123,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14304927234259905409":{"error_kind":"fmtstring","length":129,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"15689782976732326587":{"error_kind":"string","string":"PAYLOAD_SCAN_RANGE should be less than data length"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18261670735869299181":{"error_kind":"string","string":"data length is too long"}}},"bytecode":"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evexxxXvY08o3sdGKN7HTq7WY1inVOvd7b5J+t0u/wa7Vuvdx7pV693H6qv17mPdq/XuYw3Vevexxmq9+9iB1Xr3sYOq9e5jB1fr3cd6VOvdxw6p1ruP9azWu48dWq13HzusWu8+dni13n3siGq9+9iR1Xr3sV7Vevexo6r17mNHV+vdx46p1ruP9a7Wu48dW613HzuuWu8+dny13n3shGq9+9iJ1Xr3sZO07lBRHnU1evexLjpeTZ/NujV6d7sxRne7v79Zv43e/+yF5Wr07mOdavTuY8vX6N3HVqjRu4+tWKN3H1upRu8+tnKN3n1slRq9+9iqNXr3sdVq9O5jq9fo3cfWqNG7j61Zo3cfW6tG7z62do3efaxzjd59bJ0avftYZY3efSxVo3cfq6rRu49V1+jdx2pq9O5j6Rq9+1imRu8+lq3Ru4/lavTuY7Ua9558BlMV7z1jC+49VdWNtZXp+qrGxmxtVa4y3S1bWVPZrb57fXUqnarJ1Nfk6uu7dUtlqqP/Xi6TzXbvlm2sz2YaGxpT3Su752oePzLBd6iCt/eZ4r3nc8V7z0jFe88XiveeUYr3ni8V7z1fKd57Rivee75WvPd8o3jvGaN47xmreO/5VvHe853ivWec4r3ne8V7z3jFe88PiveeHxXvPRMU7z0TFe89Pynee35WvPf8onjvmaR47/lV497zV6QeSOtxlIfTeneobwvZUUNtda62W306k66uytRXVueyuVRlTUNjNhX/yEBNY6a6plt0S011bahpqK/sFv9AQlV9VVVjfIOqrqn6PLl3qBn2wfVpvXvPDWm9e8+Nab17z01pvXvPzWm9e0+/tN6955a03r3n1rTevad/Wu/ec1ta795ze1rv3nNHWu/eMyCtd++5M6137xmY1rv33JXWu/fcnda799yT1rv3DErr3XvuTevde+5L6917Bqf17j33p/XuPUPSeveeoW2/q/wdqSO1/m4qWlGvtnoVfCq9FX9fw3eFeaXTDVXV9bnabHVtbXXX+spsQ7d0NlVVVdkQAarGVKp7qro2U9NQk6tKVzVm6rvmqtM16Wz37vENKtWterrRHapT/s9WexftqD0zeveevTJ69569M3r3nn0yeveefTN69579Mnr3nv0zeveeAxR/n0rXjN69p1tG795Tr/g7drpn9O49DRm9e0+j4u9dOjCjd+85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","debug_symbols":"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deSOr5skHnHuxKNScyceuONnLUN3POSO3HFrHbnj6yZ5R5yftQxLzZ145I478cgdD7kjd9xaR+74ukneEednLaNS87OWoTvuxCN3POSO3Gl2J3DH100Sjzh34lGpuROP3HEnHrnjIXfgjt+pDN3xdZO8I87PWoal5k48cqfZncAdD7kjd9xaR+74ukniEedOPCo1d+KBO37WMnTHQ+7IHbfWkTu+bpJ3xPlZy7DU3IlH7rgTj9zxkDtyx6115I6vm+QdcX7WMio1P2sZuuNOPHLHQ+7InWZ3And83STxiHMnHpWaO/HIHXfikTsecgfu+J3K0B1fN8k74vysZVhq7sQjd5rdCdzxkDtyx6115I6vmyQece7Eo1JzJx6442ctQ3c85I7ccWsduePrJnlHnJ+1DEvNnXjkjjvxyB0PuSN33FpH7vi6Sd4R52cto1Lzs5ahO+7EI3c85I7caXYncMfXTRKPOHfiUam5E4/ccSceueMh96/d6X6nMnTH103SjrjuZy3DUnMnHrnT7E7gjofckTturSN3fN0k8YhzJx6VmjvxwB0/axm64yF35I5b68gdXzfJO+L8rGVYau7EI3fciUfueMgduePWOnLH103yjjg/axmVmp+1DN1xJx654yF35E6zO4E7vm6SeMS5E49KzZ145I478cgdD7kDd/xOZeiOr5vkHXF+1jIsNXfikTvN7gTueMgduePWOnLH100Sjzh34lGpuRMP3PGzlqE7HnJH7ri1jtwp3Fqvy/X2r2/ruu7xEde24+0fb1v/+OP1erXM9i78aFv7+Y//5Xuz74/4XjgOPOp74aDxqO+FI8yjvhdOO4/6XjhHPel75edOH/W9cPZ71PfCqfJR351Xn/G92fdHfHdefcZ359VnfHdefcZ359VnfHdefcT3yo8CP+q78+ozvjuvPuO78+ozvjf7/ojvzqvP+O68+ozvzqvP+O68+ozvzquP+F75pe1HfXdefcZ359VnfHdefcb3Zt8f8d2gjn/3PeUnXn4r/V9mvvypRem30rE7/nlg5I5/Hhi448fPQ3cM6sg74vxWelhqBnVE7jS7E7hjUEfkjlvryB2DOhKPOHfiUam5Ew/c8ePnoTsGdUTuuLWO3PG7MHlHnN9KD0vNnXjkjjvxyB0PuSN33FpH7vhdmLQjbvit9KDURum30rE77sQjdzzkjtxp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okUnRItOiBadEC06IVp0QrTohGjRCdGiE6JFJ0SLTogWPSJa9Iho0SOiRY+IFj0iWvSIaNEjokWPiBY9Ilr0iGjRE6JFT4gWPSFa9IRo0ROiRU+IFj0hWvSEaNETokVPiBY9I1r0jGjRM6JFz4gWPSNa9Ixo0TOiRc+IFj0jWvSMaNELokUviBa9IFr0gmjRC6JFL4gWvSBa9IJo0QuiRS+IFr0iWvSKaNErokVH7BmtiD2jFbFntCL2jFbEntGK2DNaEXtG3YHYNHqiArTpJypAo36iArTqJypAs36iArTrJypAw36iArTsJypA036igrTtiO2jJypI247YQHqigrTtiC2kJypI247YRHqigrTtiG2kJypI247YSHqigrTtiK2kJypI247YTHqigrTtiO2kJypI247YUHqigrTtiC2lJypI247YVHqigrTtiG2lJypI247YWOqOPc1RlOqFisrxjGqHFXU5X6hcbqDa0vQjo3KQqHbsK1eOdKEqIT2h2lJP78Px9fHz5+CfUdEWVA/L4ENqoNphRX2s8UKV3B+onj9OPn79cvI5XB92tfHhSNfmiOTp+4d/6Zs+TN/8YfqWD9O3fpa+W8r9d+q7xT5nd1z65kBPXmNLMbPP1/Cp8+f87PfHVDOHg/z18aM4/uO15C+qzh8fHz6X/gI1ppp5NCiHCMojggqIoAgRVEQElRBBZURQBREUokWviBa9Ilr0imjRK6JFr4gWvSJa9Ipo0SuiRa+AFt0dO0xCva4ztfqjAWrHRq8hXqDIN0Dt2Ojnf74+fRyu/oGqlYp111X3x8+loUW+hRblFlrUO2jhjlto4W6hhb+FFuEWWtAttIi30OIWvtvdwne7W/hudwvf7W/hu/0tfLe/he/2t/DdY6qnt2txC9/tb+G7/S18t7+F7/a38N3hFr473MJ3h1v47qDidNergPIMX8OzFqRhR4VyFfQ4OlJDixc7KpYHrFjCd1i/1oXOddS5LnauS53rcue60rmu9q17VbUurnOd6zr3S+zcL7Fzv8TO/RI790vs3C+xc7/Ezv2SOvdL6twvqXO/pM79kjr3y6v64eQf61LwT+tevficHiWOISV6XveCl1TDtS67+rwudK6jznWxc13qXJc715XOdbVv3avyzpIf+6V64t05xfRVBHz+mJ+986t6zcFS/BIpYYkUWiIlLpGS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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            /*@safety  : the msg_block is checked below in verify_msg_block*/\n            build_msg_block(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            //@safety : the msg_block is checked below in verify_msg_block\n            build_msg_block(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        //@safety : the msg_len is checked below in verify_msg_len\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe {\n            //@safety : testing context\n            build_msg_block(input, input.len(), 0)\n        };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe {\n            //@safety : testing context\n            build_msg_block(input, input.len(), 64)\n        };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe {\n            //@safety  : testing context\n            attach_len_to_msg_block(input, 1, 448)\n        };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"use jwt::JWT;\n\nglobal MAX_DATA_LENGTH: u32 = 128;\nglobal MAX_NONCE_LENGTH: u32 = 32;\n\n// this circuit is not verifying that the key matches anything\n// the verifier does this (public input to the circuit)\n\n// Trust assumption with google: google is attesting to the fact\n// that the prover has access to a certain top level domain.\n// google is also attesting to the fact\n// if the proof becomes public, Google can figure out who's it is\n// by matching the nonce\n//  - possible to fix using semaphore\n//    - create a group for each domain. prove membership to join group\n//    - google can find out that you joined the group (which they already know)\n//    - they cannot link users to messages like current impl\n//  - do it in Aztec. prove membership and then emit message in public log\n\n// partial hashing\n// stealthnote uses ephemeral\nfn main(\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    pubkey_modulus_limbs: pub [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n    // domain: pub BoundedVec<u8, MAX_DOMAIN_LENGTH>,\n    nonce: pub BoundedVec<u8, MAX_NONCE_LENGTH>,\n) {\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    // Validate key value pair in payload JSON\n    jwt.assert_claim_string::<300, 5, MAX_NONCE_LENGTH>(\"nonce\".as_bytes(), nonce);\n}\n","path":"/home/josh/Documents/Github/stealthnote_workshop/circuit/src/main.nr"},"63":{"source":"use base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::RBN2048};\nuse std::hash::sha256_var;\nuse string_search::{StringBody, SubString};\nuse zkemail::partial_hash::partial_sha256_var_end;\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature: RBN2048 = RuntimeBigNum::from_array(params, self.signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param PAYLOAD_SCAN_RANGE: The index in the data up to which we will look for the claim (from the b64_offset).\n    *                            This basically means that everything from b64_offset to PAYLOAD_SCAN_RANGE should be a valid base64 character, and the claim\n    *                            should be present in this range. This is required now due to a limitation in base64.\n    *                            If you are asserting multiple claims, it is optimal to use same PAYLOAD_SCAN_RANGE for each (max value needed).\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<PAYLOAD_SCAN_RANGE, KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `PAYLOAD_SCAN_RANGE`, `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<PAYLOAD_SCAN_RANGE, KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `PAYLOAD_SCAN_RANGE`, `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> u64 {\n        let claim = self.get_claim::<PAYLOAD_SCAN_RANGE, KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `PAYLOAD_SCAN_RANGE`, `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<PAYLOAD_SCAN_RANGE, KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> bool {\n        let value = self.get_claim::<PAYLOAD_SCAN_RANGE, KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `PAYLOAD_SCAN_RANGE`, `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<PAYLOAD_SCAN_RANGE, KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            //@safety: extract the value in unconstrained mode, and verify later\n            self.extract_claim_unconstrained::<PAYLOAD_SCAN_RANGE, KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack::<PAYLOAD_SCAN_RANGE>();\n\n        // needle is the key + a quote - searching for just the key string might return matches from elsewhere in the payload\n        let mut key_with_quote: [u8; KEY_LENGTH + 1] = [0; KEY_LENGTH + 1];\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH] = 34; // ascii for quote\n        let mut needle: SubString<(((KEY_LENGTH + 1) + 31) / 31) * 31, (KEY_LENGTH + 1) / 31, (KEY_LENGTH + 1)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (match, position): (bool, u32) = haystack.substring_match(needle);\n        assert(match, \"key not found in the payload\");\n\n        // assert value after claim_key is a quote and colon\n        assert(haystack.body[position + KEY_LENGTH + 1] == 58); // :\n\n        let mut value_offset = 0;\n        if (is_value_quoted) {\n            // assert the char before and after the value is a quote\n            assert(haystack.body[position + KEY_LENGTH + 2] == 34); // \"\n            assert(haystack.body[position + KEY_LENGTH + 3 + value.len()] == 34); // \"\n            value_offset = position + KEY_LENGTH + 3; // for two quote and colon\n        } else {\n            // numeric - assert the character after the value is a comma\n            assert(haystack.body[position + KEY_LENGTH + 2 + value.len()] == 44); // ,\n            value_offset = position + KEY_LENGTH + 2; // for a quote and colon\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_offset + i] == value.storage()[i]);\n            }\n        }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack<let PAYLOAD_SCAN_RANGE: u32>(\n        self,\n    ) -> StringBody<((((PAYLOAD_SCAN_RANGE / 4) * 3) + 31) / 31) * 31, (((PAYLOAD_SCAN_RANGE / 4) * 3) + 31) / 31, ((PAYLOAD_SCAN_RANGE / 4) * 3)> {\n        assert(\n            PAYLOAD_SCAN_RANGE % 4 == 0,\n            \"PAYLOAD_SCAN_RANGE should be a multiple of 4 to be a valid base64 chunk\",\n        );\n        assert(\n            PAYLOAD_SCAN_RANGE <= (self.data.len() - self.base64_decode_offset),\n            \"PAYLOAD_SCAN_RANGE should be less than data length\",\n        );\n\n        // Decode the payload (from the payload_b64_offset)\n        let mut payload_b64: [u8; PAYLOAD_SCAN_RANGE] = [0; PAYLOAD_SCAN_RANGE];\n        for i in 0..PAYLOAD_SCAN_RANGE {\n            payload_b64[i] = self.data.storage()[(i + self.base64_decode_offset)];\n        }\n\n        let payload: [u8; (PAYLOAD_SCAN_RANGE / 4 * 3)] = BASE64_URL_DECODER.decode(payload_b64); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<(((PAYLOAD_SCAN_RANGE / 4 * 3) + 31) / 31) * 31, ((PAYLOAD_SCAN_RANGE / 4 * 3) + 31) / 31, (PAYLOAD_SCAN_RANGE / 4 * 3)> =\n            StringBody::new(payload, payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let PAYLOAD_SCAN_RANGE: u32, let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack::<PAYLOAD_SCAN_RANGE>();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 1] = [0; KEY_LENGTH + 1];\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i] = key[i];\n        }\n        key_with_quote[KEY_LENGTH] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 1) + 31) / 31) * 31, (KEY_LENGTH + 1) / 31, (KEY_LENGTH + 1)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (match, position): (bool, u32) = haystack.substring_match(needle);\n        assert(match, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 2; // +2 for the quote and colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        println(f\"value: {value}\");\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string::<228, 5, 100>(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        980369308180926187639665375970832425,\n        697320182295162860808943349837693221,\n        111295719370222681371261928558980684,\n        876757711759763854144686376888098813,\n        1305977171055197746109619224853281860,\n        78499128846316457745067910484443041,\n        1288434305424752085723836392711950532,\n        670925248123095290513358942055339551,\n        1100788473881789342230085260152072690,\n        1308931117849855656660246918099294332,\n        841053005775200719440587138968838850,\n        1005632083239091397645271227745539000,\n        133358482832433342857843359072716231,\n        1219502865388766257580089005588604733,\n        989611545284846785089146525038812393,\n        130323933421467535642323942377974091,\n        989236701372333552745947305777768256,\n        39,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78,\n        84, 103, 53, 78, 67, 119, 105, 97, 87, 70, 48, 73, 106, 111, 120, 78, 122, 77, 51, 78, 106,\n        81, 121, 77, 106, 69, 51, 76, 67, 74, 117, 98, 50, 53, 106, 90, 83, 73, 54, 73, 106, 69,\n        121, 77, 122, 69, 121, 77, 122, 69, 121, 77, 121, 73, 115, 73, 109, 86, 116, 89, 87, 108,\n        115, 73, 106, 111, 105, 89, 87, 120, 112, 89, 50, 86, 65, 100, 71, 86, 122, 100, 67, 53,\n        106, 98, 50, 48, 105, 76, 67, 74, 108, 98, 87, 70, 112, 98, 70, 57, 50, 90, 88, 74, 112, 90,\n        109, 108, 108, 90, 67, 73, 54, 100, 72, 74, 49, 90, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        291844137, 871603302, 1977778012, 4213794212, 4080401768, 1349766907, 4032784244,\n        2198146592,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string::<120, 5, 100>(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string::<228, 5, 100>(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number::<228, 3>(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number::<228, 3>(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool::<228, 14>(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        703266088735352876175126937872530327,\n        681875825279818959348255572932830504,\n        442459484074580154827740978732118783,\n        136413207390992235035659884406647069,\n        1133253725388035431458179508721125384,\n        883148918270760489950517751041974835,\n        179750770351853240983446498126481613,\n        1014974639988607329945486359128481738,\n        268273949722077241402394499758648460,\n        1086627716642944578835866543182160013,\n        391955518875066618219286849739404497,\n        281517610791922979920479090919069944,\n        905215884171638849400535728740924582,\n        283084500521831942506996734448841322,\n        290118293627729703712069182994327542,\n        609278559811361503903618582892913762,\n        1289227696915228056735697969744622443,\n        65,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 78, 122, 65, 49, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool::<228, 14>(\"email_verified\".as_bytes(), true);\n}\n","path":"/home/josh/nargo/github.com/zkemail/noir-jwt/v0.3.1/src/lib.nr"},"64":{"source":"use super::defaults::BASE64_PADDING_CHAR;\n\n/// Standard Base64 Alphabet (base64) with padding.\npub global STANDARD: Base64DecodeBE = Base64DecodeBE::new(true);\n\n/// Standard Base64 Alphabet (base64) without padding.\npub global STANDARD_NO_PAD: Base64DecodeBE = Base64DecodeBE::new(false);\n\n/// URL and Filename Safe Alphabet without padding.\npub global URL_SAFE: Base64DecodeBE = Base64DecodeBE::base64url(false);\n\n/// URL and Filename Safe Alphabet with padding.\npub global URL_SAFE_WITH_PAD: Base64DecodeBE = Base64DecodeBE::base64url(true);\n\n/// Invalid value for the lookup table.\nglobal INVALID_VALUE: u8 = 255;\n\n/// Base64 decoder for big-endian byte arrays.\n///\n/// > Note: If the lookup table is not defined in a struct, access costs are expensive and ROM\n/// tables aren't being used.\nstruct Base64DecodeBE {\n    /// The base64 lookup table.\n    table: [u8; 256],\n    /// Whether the input has padding.\n    pad: bool,\n}\n\nimpl Base64DecodeBE {\n    /// Creates a new decoder that uses the standard Base64 Alphabet (base64) specified in RFC 4648\n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-4).\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `pad`: Whether the input has padding.\n    ///\n    /// ## Returns\n    ///\n    /// The Base64 decoder instance.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let decoder = Base64DecodeBE::new(true);\n    /// ```\n    fn new(pad: bool) -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-42\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                62, // 43\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 44-46\n                63, // 47\n                52,\n                53,\n                54,\n                55,\n                56,\n                57,\n                58,\n                59,\n                60,\n                61, // 48-57\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 58-64\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                12,\n                13,\n                14,\n                15,\n                16,\n                17,\n                18,\n                19,\n                20,\n                21,\n                22,\n                23,\n                24,\n                25, // 65-90 (A-Z)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 91-96\n                26,\n                27,\n                28,\n                29,\n                30,\n                31,\n                32,\n                33,\n                34,\n                35,\n                36,\n                37,\n                38,\n                39,\n                40,\n                41,\n                42,\n                43,\n                44,\n                45,\n                46,\n                47,\n                48,\n                49,\n                50,\n                51, // 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n            ],\n            pad,\n        }\n    }\n\n    /// Creates a new decoder that uses the URL and Filename Safe Alphabet specified in RFC 4648\n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `pad`: Whether the input has padding.\n    ///\n    /// ## Returns\n    ///\n    /// The Base64 decoder instance.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let decoder = Base64DecodeBE::base64url(true);\n    /// ```\n    fn base64url(pad: bool) -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-44 (no mapping)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                62, // 45 (-)\n                INVALID_VALUE,\n                INVALID_VALUE, // 46-47 (no mapping)\n                52,\n                53,\n                54,\n                55,\n                56,\n                57,\n                58,\n                59,\n                60,\n                61, // 48-57 (0-9)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 58-64 (no mapping)\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                12,\n                13,\n                14,\n                15,\n                16,\n                17,\n                18,\n                19,\n                20,\n                21,\n                22,\n                23,\n                24,\n                25, // 65-90 (A-Z)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 91-94 (no mapping)\n                63, // 95 (_)\n                INVALID_VALUE, // 96 (no mapping)\n                26,\n                27,\n                28,\n                29,\n                30,\n                31,\n                32,\n                33,\n                34,\n                35,\n                36,\n                37,\n                38,\n                39,\n                40,\n                41,\n                42,\n                43,\n                44,\n                45,\n                46,\n                47,\n                48,\n                49,\n                50,\n                51, // 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n            ],\n            pad,\n        }\n    }\n\n    /// Gets the lookup table value at a given index.\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `idx`: The index to get the value for.\n    ///\n    /// ## Returns\n    ///\n    /// The value from the lookup table.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let value = Base64DecodeBE::new(true).get(65);\n    /// ```\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n\n    /// Converts an array of ASCII values into a packed byte array of base64 values.\n    ///\n    /// > Note: Each Base64 value is 6 bits. This method will produce a byte array where data is\n    /// > concatenated so that there are no sparse bits (e.g. encoding 4 ASCII values produces 24\n    /// > bits of Base64 data = 3 bytes of output data).\n    ///\n    /// ## Type Parameters\n    ///\n    /// - `InputElements`: The number of input elements.\n    /// - `OutputBytes`: The number of output bytes.\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `self`: The Base64 decoder instance.\n    /// - `input`: The input array.\n    ///\n    /// ## Constraints\n    ///\n    /// - input and output lengths are correct, including padding.\n    ///\n    /// ## Returns\n    ///\n    /// The packed byte array of base64 values.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let result = Decoder::new(false).decode::<4, 3>([65, 66, 67, 68]);\n    /// ```\n    pub fn decode<let InputElements: u32, let OutputBytes: u32>(\n        self,\n        input: [u8; InputElements],\n    ) -> [u8; OutputBytes] {\n        let rem = OutputBytes % 3;\n        // Calculate the number of padding characters and the length of the input without padding\n        let num_padding_chars = if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        };\n\n        // Assert that the output length & input length are correct\n        // Every 3 output chars will be encoded as 4 base64 input chars\n        let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n        if self.pad {\n            assert(\n                encoded_length == InputElements,\n                f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n            );\n            // enforce Base64 padding is valid\n            if num_padding_chars == 2 {\n                assert(input[InputElements - 1] == BASE64_PADDING_CHAR);\n                assert(input[InputElements - 2] == BASE64_PADDING_CHAR);\n            } else if num_padding_chars == 1 {\n                assert(input[InputElements - 1] == BASE64_PADDING_CHAR);\n            }\n        } else {\n            let expected = encoded_length - num_padding_chars;\n            assert(\n                encoded_length - num_padding_chars == InputElements,\n                f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n            );\n        }\n\n        // 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n        // we pack 40 base64 values into a field element and convert into 30 bytes\n        // TODO: once we support arithmetic ops on generics, derive OutputBytes from InputBytes\n        let mut result: [u8; OutputBytes] = [0; OutputBytes];\n        let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n        let BYTES_PER_CHUNK: u32 = 30;\n        let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n            + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n        if num_chunks > 0 {\n            let final_chunk = num_chunks - 1;\n\n            for i in 0..final_chunk {\n                let mut slice: Field = 0;\n                for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                    slice *= 64;\n                    let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                    let input_byte = input[offset];\n                    let decoded = self.get(input_byte as Field);\n                    assert(\n                        decoded != INVALID_VALUE,\n                        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n                    );\n                    slice += decoded as Field;\n                }\n                let slice_bytes: [u8; 30] = slice.to_be_bytes();\n                for j in 0..BYTES_PER_CHUNK {\n                    result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n                }\n            }\n\n            // process the final chunk, which may contain padding\n            let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n            let byte_offset = final_chunk * BYTES_PER_CHUNK;\n            let base64_elements_in_final_chunk = if self.pad {\n                InputElements - base64_offset - num_padding_chars\n            } else {\n                InputElements - base64_offset\n            };\n\n            // pack the base64 values into the field element\n            let mut slice: Field = 0;\n            for j in 0..base64_elements_in_final_chunk {\n                slice *= 64;\n                let offset = base64_offset + j;\n                let input_byte = input[offset];\n                let decoded = self.get(input_byte as Field);\n                assert(\n                    decoded != INVALID_VALUE,\n                    f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n                );\n                slice += decoded as Field;\n            }\n            for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n            }\n\n            // TODO: check is it cheaper to use a constant value in `to_be_bytes` or can we use `bytes_in_final_chunk`?\n            // extract the bytes from the Field element\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n            for i in 0..num_bytes_in_final_chunk {\n                result[byte_offset + i] = slice_bytes[i];\n            }\n        }\n\n        result\n    }\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = STANDARD.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = STANDARD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = STANDARD_NO_PAD.decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = STANDARD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = STANDARD.decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE_WITH_PAD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = URL_SAFE.decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = STANDARD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = STANDARD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    let expected = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\";\n\n    let input: [u8; 816] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50,\n        104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66,\n        108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48,\n        101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73,\n        72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70,\n        48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116,\n        108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115,\n        73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98,\n        72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86,\n        115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66,\n        117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111,\n        73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72,\n        82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66,\n        104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117,\n        90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99,\n        121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87,\n        70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86,\n        117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121,\n        97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90,\n        105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87,\n        53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52,\n        103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110,\n        99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98,\n        109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50,\n        116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73,\n        103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117,\n        89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73,\n        68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116,\n        112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53,\n        73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90,\n        105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110,\n        77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74,\n        106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122,\n        73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100,\n        50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88,\n        74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74,\n        53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103, 61, 61,\n    ];\n    let result: [u8; 610] = STANDARD.decode(input);\n    assert(result == expected.as_bytes());\n\n    let input: [u8; 814] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50,\n        104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66,\n        108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48,\n        101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73,\n        72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70,\n        48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116,\n        108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115,\n        73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98,\n        72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86,\n        115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66,\n        117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111,\n        73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72,\n        82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66,\n        104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117,\n        90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99,\n        121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87,\n        70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86,\n        117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121,\n        97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90,\n        105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87,\n        53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52,\n        103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110,\n        99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98,\n        109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50,\n        116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73,\n        103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117,\n        89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73,\n        68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116,\n        112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53,\n        73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90,\n        105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110,\n        77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74,\n        106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122,\n        73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100,\n        50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88,\n        74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74,\n        53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103,\n    ];\n    let result = STANDARD_NO_PAD.decode(input);\n    assert(result == expected.as_bytes());\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = STANDARD.decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_base64/v0.3.1/src/decoder.nr"},"97":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    pub fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self;\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    pub fn modulus(self) -> Self;\n    pub fn modulus_bits() -> u32;\n    pub fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    pub fn get_limbs(self) -> [Field; N];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    pub fn __neg(self) -> Self;\n    // unconstrained\n    pub fn __add(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __div(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    pub fn __invmod(self) -> Self;\n    // unconstrained\n    pub fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_field(self);\n    pub fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    pub fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    pub fn udiv(numerator: Self, divisor: Self) -> Self;\n    pub fn umod(numerator: Self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    pub fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/runtime_bignum.nr"},"98":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    pub fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/params.nr"},"102":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/constrained_ops.nr"},"103":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/expressions.nr"},"104":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/unconstrained_ops.nr"},"105":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/unconstrained_helpers.nr"},"107":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/serialization.nr"},"110":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/utils/split_bits.nr"},"114":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/utils/u60_representation.nr"},"127":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_rsa/v0.5.1/lib/src/rsa.nr"},"129":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = dep::std::hash::sha256(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_string_search/kb/fix_index_out_of_range_bug/src/utils.nr"},"130":{"source":"mod utils;\n\npub use utils::{conditional_select, lt_f, DebugRandomEngine};\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\nfn bug_repr(needle: [u8; 32], needle_len: u32, haystack: [u8; 128]) {\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n\n#[test]\nfn bug_test() {\n    let haystack: [u8; 128] = [\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000029,\n        0x0000000000000000000000000000000000000000000000000000000000000092,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000055,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x000000000000000000000000000000000000000000000000000000000000006e,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000057,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000084,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000004,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x000000000000000000000000000000000000000000000000000000000000005a,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n\n    let needle: [u8; 32] = [\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n    let needle_len: u32 = 0x0000000000000000000000000000000000000000000000000000000000000020;\n    bug_repr(needle, needle_len, haystack);\n}\n","path":"/home/josh/nargo/github.com/noir-lang/noir_string_search/kb/fix_index_out_of_range_bug/src/lib.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","search","get_lt_predicate_f","directive_integer_quotient","directive_invert","directive_to_radix"]}